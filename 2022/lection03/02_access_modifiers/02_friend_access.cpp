#include <iostream>

using namespace std;

class A
{
// Теперь B - наш друг, и ему всё можно.
friend class B;

// Это приватное поле, только сам класс имеет к нему доступ
private:
    int secret;

// А это публичные методы, их может вызвать внешний код.
// При этом они могут читать/писать приватное поле.
// Противоречия здесь нет - внешний код говорит, *когда* хочет чего-то,
// но только сам класс определяет, *как* при этом работать с приватными полями.
public:
    A(int i) {
        secret = i;
    }

    void describe() {
        cout << "I'm A, my value is: " << secret << endl;
    }
};

class B
{
public:
    B() { 
    }

    // Класс B получает указатель на класс A и что-то с ним делает
    void run(A* a) {
        // Работаем с классом A, вызываем его публичные методы - это ок.
        // При этом он сам как-то обращается к своим приватным полям - тоже ок.
        cout << "I'm B, I'm going to handle this one: ";
        a->describe();

        // Строчки ниже теперь успешно компилятся и выполняются.

        // Чужое приватное поле нельзя читать, но друзьям можно.
        cout << "Class B run: " << a->secret << endl;
        // И писать в него друзьям тоже можно.
        a->secret = -1;
    }
};

int main()
{
    // Создаём экземпляр класса A, пусть он сделает свою работу
    A a(42);
    a.describe();

    // А так всё ещё нельзя. Класс B - друг класса A, но не main.
    cout << "Main run: " << a.secret << endl; // А так всё ещё нельзя.
    a.secret = -1;                            // Класс B - друг класса A, но не main.

    // Создаём экземпляр класса B
    B b;
    // Пробуем передать ему указатель на A для обработки
    b.run(&a);
    // Проверяем, как дела у A после обработки
    a.describe();

    return 0;
}
